

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" href="/null">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="FFrost">
  <meta name="keywords" content="">
  
    <meta name="description" content="Week 1——C++，启动！1. 学习内容本周学习内容： 1234567891011121314151617181920212223242526272829303132333435Week 1|- 二分图|  |- 二分图的判定|  |  |- 染色法|  |  |- 不存在奇环（长为奇数的环）|  |- 二分图最大匹配（匈牙利算法）|  |- 二分图最小点覆盖（König定理二分：二分图中，最">
<meta property="og:type" content="article">
<meta property="og:title" content="Week 1">
<meta property="og:url" content="http://example.com/2023/07/09/Week-1/index.html">
<meta property="og:site_name" content="FFrost">
<meta property="og:description" content="Week 1——C++，启动！1. 学习内容本周学习内容： 1234567891011121314151617181920212223242526272829303132333435Week 1|- 二分图|  |- 二分图的判定|  |  |- 染色法|  |  |- 不存在奇环（长为奇数的环）|  |- 二分图最大匹配（匈牙利算法）|  |- 二分图最小点覆盖（König定理二分：二分图中，最">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2023/07/09/pCg2WZj.png">
<meta property="og:image" content="https://s1.ax1x.com/2023/07/09/pCgfyz6.png">
<meta property="og:image" content="https://img1.imgtp.com/2023/07/09/TSmQ1pzA.gif">
<meta property="og:image" content="https://img1.imgtp.com/2023/07/09/yuKWJzdo.png">
<meta property="article:published_time" content="2023-07-09T05:25:14.000Z">
<meta property="article:modified_time" content="2023-07-09T05:26:38.432Z">
<meta property="article:author" content="FFrost">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s1.ax1x.com/2023/07/09/pCg2WZj.png">
  
  
  <title>Week 1 - FFrost</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":80,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"follow_dnt":true},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>FFrost&#39;s COSMOS</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
        style="background: url('/img/bgp1.jpg') no-repeat center center;
          background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Week 1">
              
            </span>

<!-- 添加的代码 -->
<!-- ========================================================================= -->
            
<!-- ========================================================================= -->

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-07-09 13:25" pubdate>
        2023年7月9日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Week 1</h1>
            
            <div class="markdown-body">
              <h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h1 id="——C-，启动！"><a href="#——C-，启动！" class="headerlink" title="——C++，启动！"></a>——C++，启动！</h1><h2 id="1-学习内容"><a href="#1-学习内容" class="headerlink" title="1. 学习内容"></a>1. 学习内容</h2><p>本周学习内容：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs tex">Week 1<br>|- 二分图<br>|  |- 二分图的判定<br>|  |  |- 染色法<br>|  |  |- 不存在奇环（长为奇数的环）<br>|  |- 二分图最大匹配（匈牙利算法）<br>|  |- 二分图最小点覆盖（König定理二分：二分图中，最小点覆盖=最大匹配）<br>|  |- 二分图最大独立集（二分图中，最大独立集=n-最小点覆盖）<br>|  |- 例题（关于建边）<br>|- 图的联通<br>|  |- 定义（只有概念，详细定义见下）<br>|  |  |- 无向图中的定义<br>|  |  |  |- 连通图<br>|  |  |  |- 子图<br>|  |  |  |- 连通子图<br>|  |  |  |- 连通分量（最大联通子图）<br>|  |  |- 有向图中的定义<br>|  |  |  |- 强连通图<br>|  |  |  |- 强连通子图<br>|  |  |  |- 强连通分量<br>|  |  |  |- k连通图（双连通图）<br>|  |  |  |- 割点<br>|  |  |  |- 桥<br>|  |  |  |- 双连通分量<br>|  |  |  |- 点双连通分量<br>|  |  |  |- 边双连通分量<br>|  |- 算法<br>|  |  |- 如何求强连通分量（SCC）= 如何缩点<br>|  |  |  |- Kosaraju算法<br>|  |  |  |- Tarjan算法<br>|  |  |  |- Gabow算法（略）<br>|  |  |- 如何求桥/割点<br>|  |  |  |- Tarjan算法（对还是它）<br>|  |  |- 如何求点/边双连通分量<br>|  |  |  |- Tarjan算法（啊？）<br></code></pre></td></tr></table></figure>

<h2 id="2-学习内容的模板（以及图论常用模板）"><a href="#2-学习内容的模板（以及图论常用模板）" class="headerlink" title="2. 学习内容的模板（以及图论常用模板）"></a>2. 学习内容的模板（以及图论常用模板）</h2><h3 id="二分图最大匹配（Konig算法）例题"><a href="#二分图最大匹配（Konig算法）例题" class="headerlink" title="二分图最大匹配（König算法）例题"></a><span id="muban-erfentuzuidapipei"><a href="#dingyi-erfentuzuidapipei">二分图最大匹配</a>（König算法）<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3386">例题</a></span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-type">bool</span> vis[MAXM];<br><span class="hljs-type">int</span> lst[MAXM];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">konig</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : g[u]) &#123;  <span class="hljs-comment">// auto好用的</span><br>		<span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;<br>		vis[v] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (lst[v] == <span class="hljs-number">0</span> || <span class="hljs-built_in">findargu</span>(lst[v])) &#123;<br>			lst[v] = u;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> vis);  <span class="hljs-comment">// 打时间戳可以优化常数</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">findargu</span>(i)) cnt++;<br>	&#125;<br>	cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="强连通分量（SCC）以及缩点（包含建新图）例题（附带最短路）"><a href="#强连通分量（SCC）以及缩点（包含建新图）例题（附带最短路）" class="headerlink" title="强连通分量（SCC）以及缩点（包含建新图）例题（附带最短路）"></a><span id="muban-SCC"><a href="#dingyi-SCC">强连通分量（SCC）</a>以及缩点（包含建新图）<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2169">例题（附带最短路）</a></span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-type">int</span> dfn[MAXN], low[MAXN], dfncnt;  <span class="hljs-comment">// 两个关键数组：dfn, low</span><br><span class="hljs-type">bool</span> ins[MAXN];<br><span class="hljs-type">int</span> st[MAXN], top;  <span class="hljs-comment">// 手写栈</span><br><span class="hljs-type">int</span> tag[MAXN], tagcnt;  <span class="hljs-comment">// 标记数组，tagcnt是强连通分量的个数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	dfn[u] = low[u] = ++dfncnt;<br>	ins[u] = <span class="hljs-number">1</span>;<br>	st[++top] = u;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : g[u]) &#123;<br>		<span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ins[v]) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>		tagcnt++;<br>		<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-type">int</span> v = st[top--];<br>			ins[v] = <span class="hljs-number">0</span>;<br>			tag[v] = tagcnt;<br>			<span class="hljs-keyword">if</span> (v == u) <span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 因为不确定图是否连通，所以对于每一个点都要跑一遍Tarjan</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>	&#125;<br>    <br>    <span class="hljs-comment">// 缩点(建新图)</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; h[MAXN];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tag[e[i].u] != tag[e[i].v]) &#123;<br>            h[tag[e[i].u]].<span class="hljs-built_in">push_back</span>(tag[e[i].v]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="割点-例题"><a href="#割点-例题" class="headerlink" title="割点 例题"></a><span id="muban-gedian"><a href="#dingyi-gedian">割点</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3388">例题</a></span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-type">int</span> dfn[MAXN], low[MAXN], dfncnt;<br><span class="hljs-type">int</span> tag[MAXN], tagcnt;<br><span class="hljs-comment">// 求割点不需要使用栈</span><br><br><span class="hljs-comment">// 割点</span><br><span class="hljs-type">bool</span> cut[MAXN];  <span class="hljs-comment">// 标记那些点是割点</span><br><span class="hljs-type">int</span> cnt;  <span class="hljs-comment">// 统计割点个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>	dfn[u] = low[u] = ++dfncnt;<br>	<span class="hljs-type">int</span> sons = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : g[u]) &#123;<br>		<span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br>			<span class="hljs-built_in">tarjan</span>(v, u);<br>			sons++;<br>			low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>			<span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u] &amp;&amp; !cut[u] &amp;&amp; u != rt) &#123;  <span class="hljs-comment">// 割点的判断-1</span><br>				cut[u] = <span class="hljs-number">1</span>;<br>				cnt++;<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (u == rt &amp;&amp; sons &gt;= <span class="hljs-number">2</span> &amp;&amp; !cut[u]) &#123;  <span class="hljs-comment">// 割点的判断-2</span><br>		cut[u] = <span class="hljs-number">1</span>;<br>		cnt++;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="桥-例题（没有例题，不要点开）"><a href="#桥-例题（没有例题，不要点开）" class="headerlink" title="桥 例题（没有例题，不要点开）"></a><span id="muban-bridge"><a href="#dingyi-bridge">桥</a> <del><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7">例题（没有例题，不要点开）</a></del></span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-type">int</span> dfn[MAXN], low[MAXN], dfncnt;<br><span class="hljs-type">int</span> tag[MAXN], tagcnt;<br><span class="hljs-comment">// 求桥还是不需要使用栈</span><br><br><span class="hljs-comment">// 桥（输出到stdout）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f)</span> </span>&#123;<br>	dfn[u] = low[u] = ++dfncnt;<br>	<span class="hljs-type">int</span> sons = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : g[u]) &#123;<br>		<span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br>			<span class="hljs-built_in">tarjan</span>(v, u);<br>			sons++;<br>			low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>			<span class="hljs-keyword">if</span> (low[v] &gt; dfn[u]) &#123;  <span class="hljs-comment">// 桥的判断</span><br>				cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; v &lt;&lt; endl;<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != f) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="点双连通分量-例题"><a href="#点双连通分量-例题" class="headerlink" title="点双连通分量 例题"></a><span id="muban-dianshuangliantongfenliang"><a href="#dingyi-dianshuangliantongfenliang">点双连通分量</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8435">例题</a></span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> dfn[MAXN], low[MAXN], dfncnt;<br><span class="hljs-type">int</span> tag[MAXN], tagcnt;<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> rt;<br>vector&lt;<span class="hljs-type">int</span>&gt; ans[MAXN];<br><span class="hljs-type">int</span> cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	dfn[u] = low[u] = ++dfncnt;<br>	st.<span class="hljs-built_in">push</span>(u);<br>	<span class="hljs-keyword">if</span> (u == rt &amp;&amp; !head[u]) &#123;  <span class="hljs-comment">// 判断孤立点</span><br>		ans[++cnt].<span class="hljs-built_in">push_back</span>(u);<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i; i = g[i].nxt) &#123;  <span class="hljs-comment">// 这里使用链式前向星</span><br>		<span class="hljs-type">int</span> v = g[i].to;<br>		<span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>			<span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u]) &#123;<br>				cnt++;<br>				<span class="hljs-type">int</span> p;<br>				<span class="hljs-keyword">do</span> &#123;<br>					p = st.<span class="hljs-built_in">top</span>();<br>					st.<span class="hljs-built_in">pop</span>();<br>					ans[cnt].<span class="hljs-built_in">push_back</span>(p);<br>				&#125; <span class="hljs-keyword">while</span> (v != p);<br>				ans[cnt].<span class="hljs-built_in">push_back</span>(u);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="dijkstra算法-例题0-例题1-例题2-（例题0是板子，例题1-2是缩点-最短路）"><a href="#dijkstra算法-例题0-例题1-例题2-（例题0是板子，例题1-2是缩点-最短路）" class="headerlink" title="dijkstra算法 例题0 例题1 例题2 （例题0是板子，例题1-2是缩点+最短路）"></a>dijkstra算法 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4779">例题0</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2169">例题1</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3627">例题2</a> （例题0是板子，例题1-2是缩点+最短路）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 值得注意的一点是，dijkstra算法处理最长路时会损失效率（虽然可以卡过），所以在处理最长路时使用SPFA会更加有效（尽管它死了）</span><br><span class="hljs-comment">// 上述内容对应例题2，如果使用dijkstra算法的话会WA#3</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> dis, u;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a) <span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> dis &gt; a.dis;<br>	&#125;<br>&#125;;<br><br><span class="hljs-type">bool</span> vis[MAXN];<br><span class="hljs-type">int</span> dis[MAXN];<br>priority_queue&lt;node&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>	<span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>	dis[s] = <span class="hljs-number">0</span>;<br>	q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>	<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().u;<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>;<br>		vis[u] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : h[u]) &#123;<br>			<span class="hljs-type">int</span> v = i.first, w = i.second;<br>			<span class="hljs-keyword">if</span> (dis[v] &gt; dis[u]+w) &#123;<br>				dis[v] = dis[u]+w;<br>				q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SPFA算法-例题0-例题1-（例题0是板子，例题1是缩点-最短路）"><a href="#SPFA算法-例题0-例题1-（例题0是板子，例题1是缩点-最短路）" class="headerlink" title="SPFA算法 例题0 例题1 （例题0是板子，例题1是缩点+最短路）"></a>SPFA算法 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4779">例题0</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3627">例题1</a> （例题0是板子，例题1是缩点+最短路）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// SPFA尽管死了并且它的效率要比dijkstra慢，但是其拥有良好的负环检测系统，关键是：最长路能用</span><br>vector&lt;<span class="hljs-type">int</span>&gt; h[<span class="hljs-number">500010</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">500010</span>], cnt[<span class="hljs-number">500010</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">500010</span>];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-comment">// 这是最长路并且统计的是点权，改为最短路/统计边权只要参考dijhstra就好</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> dis);  <span class="hljs-comment">// 最短路需改</span><br>	<span class="hljs-type">int</span> f = tag[s];<br>	q.<span class="hljs-built_in">push</span>(f);<br>	dis[f] = mon[f];<br>	vis[f] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		vis[u] = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : h[u]) &#123;<br>			<span class="hljs-keyword">if</span> (dis[i] &lt; dis[u]+mon[i]) &#123;  <span class="hljs-comment">// 最短路/统计边权需改</span><br>				dis[i] = dis[u]+mon[i];  <span class="hljs-comment">// 最短路/统计边权需改</span><br>				cnt[i] = cnt[u]+<span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span> (cnt[i] &gt;= tagcnt) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>					q.<span class="hljs-built_in">push</span>(i);<br>					vis[i] = <span class="hljs-number">1</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-学习内容——各种定义"><a href="#3-学习内容——各种定义" class="headerlink" title="3. 学习内容——各种定义"></a>3. 学习内容——各种定义</h2><h3 id="强连通-x2F-连通图"><a href="#强连通-x2F-连通图" class="headerlink" title="强连通&#x2F;连通图"></a>强连通&#x2F;连通图</h3><p>在无向图中，任意两点都直接或间接连通，则称该图为 <strong>连通图(connected)</strong>.</p>
<p>相应的，有向图中任意一点都存在路径到达任意另一点，则称该有向图为 <strong>强连通图(strong connected)</strong> .</p>
<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>在一个图$ H $中，$H$的所有边属于图$G$的所有边，$H$的所有点属于图$G$的所有点，则称图$H$是图$G$的 <strong>子图(subgraph)</strong> .</p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p>无向图$G$的最大连通子图称为$G$的 <strong>连通分量(connected components)</strong> .</p>
<p>何为最大连通子图？这个子图是$G$的连通子图，将$G$的任何一个不在这张子图中的点加入这张子图后，该子图不再连通.</p>
<h3 id="强连通分量（SCC）模板"><a href="#强连通分量（SCC）模板" class="headerlink" title="强连通分量（SCC）模板"></a><span id="dingyi-SCC">强连通分量（SCC）<a href="#muban-SCC">模板</a></span></h3><p>在任意有向图中能够实现强连通的部分我们称其为 **强连通分量(Strongly connected component)**，如下图，蓝色框内的分别是一个强连通分量.</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pCg2WZj"><img src="https://s1.ax1x.com/2023/07/09/pCg2WZj.png" srcset="/img/loading.gif" lazyload alt="pCg2WZj.png"></a></p>
<p>如果把每个强连通分量收缩为单个顶点，得到的是一个 **有向无环图(DAG)**，于是我们可以在这个图的基础上进行拓扑排序，详见<a href="">此例题</a>.</p>
<p>而求这个强连通分量，我们可以使用两个算法：<strong>Kosaraju算法</strong>，<strong>Tarjan算法</strong>.</p>
<p>Kosaraju算法的流程如下：</p>
<ol>
<li>重复寻找图$G$中未被讨论的点，从它开始DFS<strong>后序</strong>遍历图$G$，遍历到的点置为已讨论，用数组记录每个点到达的先后次序，直到找不到没有讨论的点.</li>
<li>将图$G$反向得到图$G’$，重置所有点为未讨论.</li>
<li>一直从数组中未讨论的最后一个点出发，DFS<strong>后续</strong>遍历图$G’$，DFS每完成一次，就说明找到了一个强连通分量，直到数组中没有未讨论的点.</li>
</ol>
<p>这是Kosaraju算法的模板（之所以Kosaraju算法没有放在SCC的模板内，是因为这个算法相对于Tarjan算法少用很多）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> g[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];  <span class="hljs-comment">// 这里使用的是邻接矩阵</span><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> lis[<span class="hljs-number">1001</span>], cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tag[<span class="hljs-number">1001</span>], scc = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> ind[<span class="hljs-number">1001</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	vis[u] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (g[u][i] &amp;&amp; !vis[i]) <span class="hljs-built_in">dfs1</span>(i);<br>	&#125;<br>	lis[++cnt] = u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>	vis[u] = <span class="hljs-number">1</span>;<br>	tag[u] = scc;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (g[i][u] &amp;&amp; !vis[i]) <span class="hljs-built_in">dfs2</span>(i);  <span class="hljs-comment">// 这里注意，判断的边是g[i][u]，因为我们要在反图上跑dfs2()</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 这里可以用memset</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (!vis[i]) <span class="hljs-built_in">dfs1</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cnt; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>		<span class="hljs-keyword">if</span> (!vis[lis[i]]) &#123;<br>			scc++;<br>			<span class="hljs-built_in">dfs2</span>(lis[i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>			<span class="hljs-keyword">if</span> ((tag[i] != tag[j]) &amp;&amp; g[i][j]) &#123;<br>                <span class="hljs-comment">// 此处为缩点</span><br>            &#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><span id="temp-tarjan">接下来我们来说说Tarjan算法，这个算法相对于上个算法理解起来要困难些.</span></p>
<p>在Tarjan算法中，最为重要的两个数组是<code>dfn[]</code>和<code>low[]</code>，<code>dfn[i]</code>记录的是编号为i的节点在DFS的整个过程的顺序，它会在第一次访问到i节点时更改，此后将不会变化；<code>low[i]</code>表示的是<code>i</code>与其之后遍历到的节点所能到达的节点中<code>dfn</code>最小的<code>dfn</code>，在初始化时<code>dfn[i]=low[i]</code>.</p>
<p>Tarjan算法在运行时会生成一棵搜索树，但是我们知道，图!&#x3D;树，因为图中有一些边会使得“树”有环，自然，在生成树后，有一些边会直接指向已遍历的节点，没遍历的节点会在下一步当作自己的孩子进行遍历，而指向已遍历节点的边就是导致“树”有环的罪魁祸首.按照定义，当发现有这种边的存在时，需要更新当前节点的<code>low[]</code>值，需要更新为<code>min(dfn[这些边指向的节点])</code>.而理所当然地，我们也要被孩子节点更新<code>low</code>值为<code>min(low[孩子节点])</code>.</p>
<p>现在我们聚焦某一个点<code>i</code>，观察<code>dfn[i]</code>与<code>low[i]</code>的关系，以下是两种情况：</p>
<ol>
<li><code>dfn[i]&gt;low[i]</code>，这说明<code>i</code>或其子孙节点存在边连到<code>i</code>上方的节点.</li>
<li><code>dfn[i]=low[i]</code>，这说明<code>i</code>以及其子孙节点无法连到<code>i</code>上方的节点，那么这个点<code>i</code>就是一个强连通分量在这颗搜索树的根.</li>
</ol>
<p>但是，<code>i</code>的子孙节点有可能会组成另一个强连通分量，这意味着<code>i</code>的子树的节点不一定和<code>i</code>处在同一个强连通分量内，我们需要 <strong>栈</strong> 来解决这个问题.</p>
<p>现在，我们用一张图看一下<code>dfn[]</code>与<code>low[]</code>的关系。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pCgfyz6"><img src="https://s1.ax1x.com/2023/07/09/pCgfyz6.png" srcset="/img/loading.gif" lazyload alt="pCgfyz6.png"></a></p>
<p>在这张图中，有<code>(3,4,5,6)</code>，<code>7</code>，<code>8</code>，<code>1</code>，<code>2</code>这四个强连通块.</p>
<p>下图是Tarjan算法的运行过程.</p>
<p><img src="https://img1.imgtp.com/2023/07/09/TSmQ1pzA.gif" srcset="/img/loading.gif" lazyload alt="Tarjan_s_Algorithm_Animation.gif"></p>
<p>因为SCC模板就是Tarjan算法，所以在这里不放代码.</p>
<h3 id="二分图的最大匹配-模板"><a href="#二分图的最大匹配-模板" class="headerlink" title="二分图的最大匹配 模板"></a><span id="dingyi-erfentuzuidapipei">二分图的最大匹配 <a href="#muban-erfentuzuidapipei">模板</a></span></h3><p>何为二分图？二分图是一种特殊的<strong>无向</strong>图，它的顶点可以被分为两个互斥的独立集$U$和$V$的图，使得所有边都是连结一个$U$中的点和一个$V$中的点（如下图所示）.</p>
<p><img src="https://img1.imgtp.com/2023/07/09/yuKWJzdo.png" srcset="/img/loading.gif" lazyload alt="Simple-bipartite-graph.svg.png"></p>
<p>何为匹配？一个图的匹配是这个图中一些边所形成的集合，满足任意集合中的两条边都没有公共顶点.</p>
<p>解决这个问题的算法之一是匈牙利算法.在了解这个算法之前，我们先要了解一下何为增广路（增广轨&#x2F;交错轨）.</p>
<p>增广路：若$P$是图$G$中一条连通两个未匹配顶点的路径，并且已匹配和未匹配的边（也就是属匹配边集$M$的边和不属$M$的边）在$P$上交替出现，则称$P$为相对于$M$的一条增广路径.</p>
<p>不难发现，如果我们把$P$中原来属于$M$边从$M$中删除，把$P$中原来不属于$M$边加入到$M$中，变化后得到的新的匹配$M’$恰好比原匹配多一条边.</p>
<p>而匈牙利算法就是不断寻找增广路$P$，通过取反操作得到更大的匹配$M’$来代替$M$.</p>
<p>代码如模板所示.</p>
<h3 id="割点-模板"><a href="#割点-模板" class="headerlink" title="割点 模板"></a><span id="dingyi-gedian">割点 <a href="#muban-gedian">模板</a></span></h3><p>是无向连通图中一个顶点 $v$, 如果删除它以及它关联的边后，得到的新图至少包含两个连通分量.</p>
<p>这里同样使用Tarjan算法.</p>
<p>思路和<a href="#temp-tarjan">求SCC的Tarjan算法</a>类似，这里直接给出结论：</p>
<p>一个顶点$u$是割点，当且仅当满足条件 $1$ 或 $2$.</p>
<p>$1.$ $u$为树根，且$u$有两棵及以上的子树（这很好理解吧）.</p>
<p>$2.$ $u$不为树根，且满足存在一条$(u,v)$为树枝边使得<code>dfn[u] &lt;= low[v]</code>，即$u$有一个孩子无法到达$u$以上的点.</p>
<p>代码如模板所示.</p>
<h3 id="桥-模板"><a href="#桥-模板" class="headerlink" title="桥 模板"></a><span id="dingyi-bridge">桥 <a href="#muban-bridge">模板</a></span></h3><p>是无向连通图中的一条边，如果删除它，得到的新图包含两个连通分量.</p>
<p>求桥和求割点差不多，可以直接从代码看出差别，而且判断条件的理解也和求割点差不多，此处不过多赘述.</p>
<h3 id="双连通图"><a href="#双连通图" class="headerlink" title="双连通图"></a>双连通图</h3><p>不含割点的无向连通图.</p>
<h3 id="双连通分量"><a href="#双连通分量" class="headerlink" title="双连通分量"></a>双连通分量</h3><p>无向连通图的最大双连通子图.</p>
<h3 id="点双连通分量-模板"><a href="#点双连通分量-模板" class="headerlink" title="点双连通分量 模板"></a><span id="dingyi-dianshuangliantongfenliang">点双连通分量 <a href="#muban-dianshuangliantongfenliang">模板</a></span></h3><p>通过找割点获得的双连通分量（层层递进.jpg.</p>
<h3 id="边双连通分量-（模板没打）"><a href="#边双连通分量-（模板没打）" class="headerlink" title="边双连通分量 （模板没打）"></a>边双连通分量 （模板没打）</h3><p>通过找桥获得的双连通分量.</p>
<h2 id="4-心得体会"><a href="#4-心得体会" class="headerlink" title="4. 心得体会"></a>4. 心得体会</h2><p>主要是图论之前有接触过，所以理解概念会比较快，同时在这一周我把之前一直没弄懂的Tarjan算法搞懂了.</p>
<p>现在的问题主要是建边的技巧以及破题的能力，像这种题（<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2403">[SDOI2010]所驼门王的宝藏</a>），这些建边的技巧想不到.</p>
<p>图论的常识有些遗忘了，例如Dijkstra跑最长路不能保证时间复杂度这类东西.</p>
<h2 id="5-常用网站收集"><a href="#5-常用网站收集" class="headerlink" title="5. 常用网站收集"></a>5. 常用网站收集</h2><p><a target="_blank" rel="noopener" href="https://imgse.com/">路过图床</a></p>
<p><a target="_blank" rel="noopener" href="https://www.imgtp.com/">ImgTP</a></p>
<p><a target="_blank" rel="noopener" href="https://csacademy.com/app/graph_editor/">生成图</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/">OI Wiki</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/14/Password-sir/">
                        <span class="hidden-mobile">Password, sir?</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  <div>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("05/14/2023 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
    }  //此次自定义显示内容
    setInterval("createtime()",250);
    </script>
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js" ></script>
  





 <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
<script
  src="https://sdk.jinrishici.com/v2/browser/jinrishici.js"
  charset="utf-8"
></script>

<script>
  function typing(id, title){
      var typed = new Typed('#' + id, {
          strings: [
            ' ',
            title + " ",
          ],
          cursorChar: "",
          typeSpeed: 80,
          loop: false,
      });
      typed.stop();
      $(document).ready(function () {
          $(".typed-cursor").addClass("h2");
          typed.start();
      });
  }

  
      typing("subtitle", "Week 1")  // 打印文章标题
  
</script>

<!-- 注意，不能用代码格式化插件格式化代码 -->

<!-- typing("hitokoto", data.hitokoto + '<br /> <h5>' + '——' + data.from + '</h5>')
typing("hitokoto", '『' + data.hitokoto + '』' + '<br /> <h5>'+ '——' + '「' + data.from + '」' + '</h5>') -->













<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

<!-- 注意，不能用代码格式化插件格式化代码 -->